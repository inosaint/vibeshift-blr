<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chaos Typewriter - Vibeshift BLR</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Quicksand', 'Nunito', 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #fce4ec 0%, #e8eaf6 25%, #e0f7fa 50%, #f3e5f5 75%, #fff9c4 100%);
      background-attachment: fixed;
      color: #4a3f6b;
      min-height: 100vh;
    }

    nav {
      padding: 0.75rem 1.5rem;
      background: rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(200, 160, 220, 0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    nav a {
      color: #9c6bc4;
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    nav a:hover { color: #7b40a8; text-decoration: underline; }

    .nav-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .setup-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      cursor: pointer;
      user-select: none;
      font-size: 0.85rem;
      font-weight: 600;
      color: #b07cd8;
      background: none;
      border: none;
      padding: 0.5rem;
      min-height: 44px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .setup-toggle:hover { color: #8e44ad; }

    .help-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid rgba(186, 140, 214, 0.4);
      background: rgba(255, 255, 255, 0.45);
      color: #b07cd8;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, border-color 0.15s;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .help-btn:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: #c084e0;
      color: #8e44ad;
    }

    .setup-toggle .arrow {
      display: inline-block;
      transition: transform 0.2s;
      font-size: 0.7rem;
    }

    .setup-toggle .arrow.open { transform: rotate(90deg); }

    .setup-panel {
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(200, 160, 220, 0.2);
      padding: 0 1.5rem;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }

    .setup-panel.open {
      max-height: 400px;
      padding: 1rem 1.5rem;
    }

    .setup-row {
      margin-bottom: 0.75rem;
    }

    .difficulty-options {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.3rem;
    }

    .diff-btn {
      flex: 1;
      padding: 0.6rem 0.5rem;
      border-radius: 10px;
      border: 2px solid rgba(186, 140, 214, 0.3);
      background: rgba(255, 255, 255, 0.4);
      color: #4a3f6b;
      font-family: inherit;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      text-align: center;
      transition: background 0.15s, border-color 0.15s;
      min-height: 44px;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .diff-btn:hover {
      background: rgba(255, 255, 255, 0.6);
      border-color: #c084e0;
    }

    .diff-btn.active {
      background: rgba(186, 140, 214, 0.25);
      border-color: #b07cd8;
      color: #7e57c2;
    }

    .diff-btn .diff-label {
      display: block;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .diff-btn .diff-desc {
      display: block;
      font-size: 0.65rem;
      font-weight: 500;
      color: #9c6bc4;
      margin-top: 0.15rem;
    }

    .setup-panel label {
      display: block;
      font-size: 0.8rem;
      color: #9c6bc4;
      margin-bottom: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
    }

    .setup-panel input {
      width: 100%;
      background: rgba(255, 255, 255, 0.6);
      border: 2px solid rgba(186, 140, 214, 0.3);
      border-radius: 10px;
      padding: 0.6rem 0.8rem;
      color: #4a3f6b;
      font-family: inherit;
      font-size: 0.85rem;
      outline: none;
      transition: border-color 0.2s;
    }

    .setup-panel input:focus {
      border-color: #c084e0;
      box-shadow: 0 0 0 3px rgba(192, 132, 224, 0.15);
    }

    .header {
      padding: 0.75rem 1.5rem 0.25rem;
      text-align: center;
      margin-bottom: 0.5rem;
    }

    .header h1 {
      font-size: 1.6rem;
      font-weight: 700;
    }

    .header h1 .title-chaos {
      color: #4a3f6b;
    }

    .header h1 .title-typewriter {
      color: #b07cd8;
    }

    .header .byline {
      font-size: 0.95rem;
      color: #b07cd8;
      font-weight: 500;
      margin-top: 0.25rem;
    }


    /* Sequencer canvas */
    #sequencer-container {
      width: 100%;
      min-height: 50px;
    }

    #sequencer-container canvas {
      display: block;
      border-radius: 12px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* Game area */
    .game-area {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.5rem;
      width: 100%;
      max-width: 700px;
      margin: 0 auto;
      padding: 0 1rem;
    }


    /* Keyboard */
    .keyboard {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 6px;
      max-width: 700px;
      margin: 0 auto;
      padding: 0.5rem 1rem;
      padding-bottom: env(safe-area-inset-bottom, 0.5rem);
      z-index: 10;
    }

    .kb-row {
      display: flex;
      gap: 5px;
      justify-content: center;
    }

    .key {
      height: 50px;
      min-width: 36px;
      flex: 1;
      padding: 0 10px;
      border-radius: 8px;
      border: none;
      background: rgba(255, 255, 255, 0.55);
      backdrop-filter: blur(6px);
      color: #4a3f6b;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.15s, transform 0.1s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .key:hover { background: rgba(255, 255, 255, 0.75); }
    .key:active { transform: scale(0.95); }

    .key.wide {
      flex: 0 0 60px;
      font-size: 0.7rem;
    }
    .key.breathe-key {
      flex: 1;
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .key.faded {
      opacity: 0.15;
      pointer-events: none;
      transition: opacity 0.6s ease;
    }

    .key.correct {
      background: #a0d8c0;
      color: #2d5e45;
    }

    .key.present {
      background: #e8a0bf;
      color: #6b2f4a;
    }

    .key.absent {
      background: rgba(186, 140, 214, 0.2);
      color: #8a7ba0;
    }

    /* Hint + stats row */
    .hint-stats-row {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      min-height: 3em;
      width: 100%;
      gap: 1rem;
    }

    .hint-bubble-wrap {
      flex: 1;
      min-width: 0;
    }

    .hint-bubble {
      display: flex;
      align-items: flex-start;
      gap: 0.6rem;
      background: rgba(255, 255, 255, 0.55);
      border: none;
      border-radius: 8px;
      padding: 0.5rem 0.8rem;
      position: relative;
      margin-left: 2.6rem;
    }

    .hint-bubble::before {
      content: '';
      position: absolute;
      left: -8px;
      top: 12px;
      width: 0;
      height: 0;
      border-top: 6px solid transparent;
      border-bottom: 6px solid transparent;
      border-right: 8px solid rgba(255, 255, 255, 0.55);
    }

    .hint-icon {
      position: absolute;
      left: -2.4rem;
      top: 0;
      width: 2rem;
      height: 2rem;
      border-radius: 50%;
      object-fit: cover;
    }

    .hint-content {
      flex: 1;
      min-width: 0;
    }

    .hint-bubble .hint-personality {
      display: block;
      font-weight: 700;
      font-size: 0.7rem;
      color: #4a3f6b;
      margin-bottom: 0.15rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .hint-bubble .hint-text {
      color: #4a3f6b;
      font-size: 0.85rem;
      font-weight: 500;
      line-height: 1.4;
    }

    .hint-bubble.waiting {
      opacity: 0.7;
    }

    .hint-bubble .hint-waiting {
      color: #b07cd8;
      font-style: italic;
      font-size: 0.85rem;
    }

    .game-stats {
      flex-shrink: 0;
      text-align: right;
      font-size: 0.7rem;
      color: #8a7ba0;
      line-height: 1.4;
      white-space: nowrap;
      padding-top: 0.15rem;
      padding-right: 0.5rem;
    }

    .game-stats .stat-number {
      font-weight: 700;
      color: #4a3f6b;
    }

    .game-stats .stat-label {
      font-weight: 500;
      color: #b07cd8;
    }


    /* Modals */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(40, 20, 60, 0.45);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      animation: fade-in 0.3s ease;
    }

    @keyframes fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal {
      background: linear-gradient(135deg, #fce4ec 0%, #e8eaf6 25%, #e0f7fa 50%, #f3e5f5 75%, #fff9c4 100%);
      border: 1px solid rgba(200, 160, 220, 0.35);
      border-radius: 20px;
      padding: 2rem 2.5rem;
      text-align: center;
      max-width: 380px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(100, 60, 140, 0.15);
    }

    .modal.guide {
      text-align: left;
    }

    .modal.guide .btn {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }

    .modal.guide h2 {
      text-align: center;
      margin-bottom: 1.25rem;
    }

    .modal.guide p {
      font-size: 0.85rem;
      line-height: 1.5;
      margin-bottom: 0.6rem;
      color: #4a3f6b;
    }

    .modal.guide .twist {
      background: rgba(255, 255, 255, 0.35);
      border-radius: 10px;
      padding: 0.6rem 0.75rem;
      margin: 0.75rem 0;
      font-size: 0.82rem;
      line-height: 1.5;
      color: #6b4a8a;
    }

    .modal-icon {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
    }

    .modal h2 {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4a3f6b;
      margin-bottom: 0.3rem;
    }

    .modal .modal-stats {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-bottom: 1.2rem;
    }

    .modal .modal-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .modal .modal-stat .stat-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4a3f6b;
    }

    .modal .modal-stat .stat-label {
      font-size: 0.65rem;
      font-weight: 600;
      color: #b07cd8;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    /* Word history list in game over */
    .word-list {
      margin: 0.75rem 0;
      text-align: left;
      max-height: 180px;
      overflow-y: auto;
    }

    .word-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.3rem 0.5rem;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .word-item:nth-child(odd) {
      background: rgba(255, 255, 255, 0.3);
    }

    .word-item .word-text {
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #4a3f6b;
    }

    .word-item .word-badge {
      font-size: 0.7rem;
      font-weight: 700;
      padding: 0.15rem 0.5rem;
      border-radius: 20px;
    }

    .word-item .word-badge.solved {
      background: #a0d8c0;
      color: #2d5e45;
    }

    .word-item .word-badge.missed {
      background: #e8a0bf;
      color: #6b2f4a;
    }

    .current-word-reveal {
      font-size: 1.1rem;
      font-weight: 700;
      color: #7e57c2;
      letter-spacing: 0.15em;
      margin-bottom: 0.5rem;
    }

    .btn {
      margin-top: 0.5rem;
      padding: 0.75rem 1.5rem;
      border-radius: 10px;
      border: 2px solid rgba(186, 140, 214, 0.3);
      background: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(6px);
      color: #9c6bc4;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      min-height: 44px;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.7);
      border-color: #c084e0;
    }

    /* Start overlay */
    .start-overlay {
      position: fixed;
      inset: 0;
      background: rgba(40, 20, 60, 0.45);
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      cursor: pointer;
      animation: fade-in 0.3s ease;
    }

    .start-box {
      background: linear-gradient(135deg, #fce4ec 0%, #e8eaf6 25%, #e0f7fa 50%, #f3e5f5 75%, #fff9c4 100%);
      border: 1px solid rgba(200, 160, 220, 0.35);
      border-radius: 20px;
      padding: 2rem 2.5rem;
      text-align: center;
      max-width: 380px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(100, 60, 140, 0.15);
    }

    .start-box h2 {
      font-size: 1.3rem;
      font-weight: 700;
      color: #4a3f6b;
      margin-bottom: 0.5rem;
    }

    .start-box p {
      font-size: 0.85rem;
      color: #7a6a9a;
      line-height: 1.5;
      margin-bottom: 1rem;
    }

    #root {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .hidden { display: none !important; }

    @media (max-width: 480px) {
      .key { height: 44px; min-width: 28px; padding: 0 7px; font-size: 0.75rem; }
      .key.wide { min-width: 48px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
  // ── Audio Engine (Tone.js) — 5 voices per vibe ─────────────────
  // Scale degrees for 6 rows (row 0 = high, row 5 = low)
  const SCALES = {
    lydian:    [11, 9, 6, 4, 2],   // dreamy — 5 rows
    wholetone: [10, 8, 6, 4, 2],    // glitchy
    pentminor: [12, 7, 5, 3, 0],    // calm
    phrygian:  [12, 8, 7, 5, 1],    // tense
  };

  const VIBES = {
    glitchy: {
      label: 'Glitchy', desc: 'Bit-crushed chaos',
      scale: SCALES.wholetone,
      voices: [
        { // block 0 — metallic hits
          makeSynth(fx) { return new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.15, release: 0.1 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5, volume: -14 }).connect(fx); },
          makeFx() { const c = new Tone.BitCrusher(4); c.toDestination(); return c; },
          trigger(synth, freq) { synth.frequency = freq; synth.triggerAttackRelease('16n'); },
        },
        { // block 1 — AM glitch
          makeSynth(fx) { return new Tone.AMSynth({ oscillator: { type: 'square' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }, volume: -16 }).connect(fx); },
          makeFx() { const d = new Tone.PingPongDelay('8n', 0.3); d.wet.value = 0.2; d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '16n'); },
        },
        { // block 2 — pluck
          makeSynth(fx) { return new Tone.PluckSynth({ attackNoise: 2, dampening: 2000, resonance: 0.9, volume: -12 }).connect(fx); },
          makeFx() { const c = new Tone.BitCrusher(6); c.toDestination(); return c; },
          trigger(synth, freq) { synth.triggerAttack(freq); },
        },
        { // block 3 — mono
          makeSynth(fx) { return new Tone.MonoSynth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -18 }).connect(fx); },
          makeFx() { const d = new Tone.Distortion(0.8); d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '32n'); },
        },
        { // block 4 — percussion
          makeSynth(fx) { return new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }, volume: -14 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 0.5, wet: 0.15 }); r.toDestination(); return r; },
          trigger(synth, freq, row) { synth.triggerAttackRelease('32n'); },
          isDrum: true,
        },
      ],
    },
    calm: {
      label: 'Calm', desc: 'Soft & warm',
      scale: SCALES.pentminor,
      voices: [
        { // block 0 — soft pad
          makeSynth(fx) { return new Tone.FMSynth({ harmonicity: 2, modulationIndex: 5, oscillator: { type: 'sine' }, envelope: { attack: 0.2, decay: 0.4, sustain: 0.3, release: 1.2 }, volume: -16 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 4, wet: 0.6 }); r.toDestination(); return r; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '4n'); },
        },
        { // block 1 — bell
          makeSynth(fx) { return new Tone.FMSynth({ harmonicity: 6, modulationIndex: 2, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.8, sustain: 0, release: 0.5 }, volume: -18 }).connect(fx); },
          makeFx() { const d = new Tone.FeedbackDelay('4n', 0.2); d.wet.value = 0.2; d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '8n'); },
        },
        { // block 2 — pluck
          makeSynth(fx) { return new Tone.PluckSynth({ attackNoise: 0.5, dampening: 3000, resonance: 0.95, volume: -14 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 3, wet: 0.4 }); r.toDestination(); return r; },
          trigger(synth, freq) { synth.triggerAttack(freq); },
        },
        { // block 3 — keys
          makeSynth(fx) { return new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.6 }, volume: -16 }).connect(fx); },
          makeFx() { const d = new Tone.FeedbackDelay('8n', 0.15); d.wet.value = 0.15; d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '8n'); },
        },
        { // block 4 — soft percussion
          makeSynth(fx) { return new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 4, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.3 }, volume: -16 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 2, wet: 0.3 }); r.toDestination(); return r; },
          trigger(synth, freq, row) { const pitches = ['C5','A4','F4','D4','A3']; synth.triggerAttackRelease(pitches[row] || 'C3', '8n'); },
          isDrum: true,
        },
      ],
    },
    dreamy: {
      label: 'Dreamy', desc: 'Floaty plucks',
      scale: SCALES.lydian,
      voices: [
        { // block 0 — pad
          makeSynth(fx) { return new Tone.FMSynth({ harmonicity: 2, modulationIndex: 3, oscillator: { type: 'sine' }, envelope: { attack: 0.3, decay: 0.5, sustain: 0.4, release: 1.5 }, volume: -18 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 5, wet: 0.6 }); r.toDestination(); return r; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '4n'); },
        },
        { // block 1 — bell
          makeSynth(fx) { return new Tone.FMSynth({ harmonicity: 8, modulationIndex: 1.5, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 1, sustain: 0, release: 0.8 }, volume: -16 }).connect(fx); },
          makeFx() { const c = new Tone.Chorus(4, 2.5, 0.5); c.wet.value = 0.4; c.start(); c.toDestination(); return c; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '8n'); },
        },
        { // block 2 — pluck
          makeSynth(fx) { return new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.95, volume: -10 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 5, wet: 0.6 }); const c = new Tone.Chorus(4, 2.5, 0.5); c.wet.value = 0.4; c.start(); r.connect(c); c.toDestination(); return r; },
          trigger(synth, freq) { synth.triggerAttack(freq); },
        },
        { // block 3 — keys
          makeSynth(fx) { return new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.08, decay: 0.4, sustain: 0.1, release: 1 }, volume: -14 }).connect(fx); },
          makeFx() { const d = new Tone.FeedbackDelay('4n', 0.2); d.wet.value = 0.2; d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '8n'); },
        },
        { // block 4 — dreamy percussion
          makeSynth(fx) { return new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 6, envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.4 }, volume: -14 }).connect(fx); },
          makeFx() { const r = new Tone.Reverb({ decay: 3, wet: 0.5 }); r.toDestination(); return r; },
          trigger(synth, freq, row) { const pitches = ['C5','G4','E4','C4','G3']; synth.triggerAttackRelease(pitches[row] || 'C3', '8n'); },
          isDrum: true,
        },
      ],
    },
    tense: {
      label: 'Tense', desc: 'Dark & gritty',
      scale: SCALES.phrygian,
      voices: [
        { // block 0 — dark pad
          makeSynth(fx) { return new Tone.MonoSynth({ oscillator: { type: 'sawtooth' }, filter: { Q: 4, type: 'lowpass', rolloff: -24 }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.3, release: 0.6 }, volume: -18 }).connect(fx); },
          makeFx() { const d = new Tone.Distortion(0.3); d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '8n'); },
        },
        { // block 1 — stab
          makeSynth(fx) { return new Tone.MonoSynth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.2 }, volume: -16 }).connect(fx); },
          makeFx() { const f = new Tone.AutoFilter('2n').start(); f.wet.value = 0.3; f.toDestination(); return f; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '16n'); },
        },
        { // block 2 — metallic
          makeSynth(fx) { return new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.2, release: 0.1 }, harmonicity: 3, modulationIndex: 16, volume: -16 }).connect(fx); },
          makeFx() { const d = new Tone.Distortion(0.5); d.toDestination(); return d; },
          trigger(synth, freq) { synth.frequency = freq; synth.triggerAttackRelease('16n'); },
        },
        { // block 3 — bass
          makeSynth(fx) { return new Tone.MonoSynth({ oscillator: { type: 'sawtooth' }, filter: { Q: 6, type: 'lowpass' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.2, release: 0.4 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.4, baseFrequency: 200, octaves: 4 }, volume: -18 }).connect(fx); },
          makeFx() { const d = new Tone.Distortion(0.4); d.toDestination(); return d; },
          trigger(synth, freq) { synth.triggerAttackRelease(freq, '16n'); },
        },
        { // block 4 — aggressive percussion
          makeSynth(fx) { return new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }, volume: -12 }).connect(fx); },
          makeFx() { const d = new Tone.Distortion(0.6); d.toDestination(); return d; },
          trigger(synth, freq, row) { synth.triggerAttackRelease('16n'); },
          isDrum: true,
        },
      ],
    },
  };

  const AudioEngine = {
    ready: false,
    voices: [null, null, null, null, null],   // 5 synths
    fxChains: [null, null, null, null, null],  // 5 FX chains
    drone: null,
    droneGain: null,
    currentVibe: null,
    baseFreq: 220,

    async init() {
      if (this.ready) return;
      await Tone.start();
      this.ready = true;
    },

    setVibe(vibeKey) {
      if (this.currentVibe === vibeKey) return;
      // Dispose old voices
      for (let i = 0; i < 5; i++) {
        if (this.voices[i]) { try { this.voices[i].dispose(); } catch(e) {} }
        if (this.fxChains[i]) { try { this.fxChains[i].dispose(); } catch(e) {} }
      }
      const vibe = VIBES[vibeKey];
      for (let i = 0; i < 5; i++) {
        this.fxChains[i] = vibe.voices[i].makeFx();
        this.voices[i] = vibe.voices[i].makeSynth(this.fxChains[i]);
      }
      this.currentVibe = vibeKey;
    },

    getFreq(row) {
      const vibe = VIBES[this.currentVibe];
      if (!vibe || row < 0 || row >= vibe.scale.length) return this.baseFreq;
      return this.baseFreq * Math.pow(2, vibe.scale[row] / 12);
    },

    playNote(col, row, chaosLevel) {
      if (!this.ready || !this.currentVibe) return;
      const block = Math.floor(col / 3); // colToBlock
      const voice = this.voices[block];
      const voiceCfg = VIBES[this.currentVibe].voices[block];
      if (!voice || !voiceCfg) return;
      try {
        if (voiceCfg.isDrum) {
          voiceCfg.trigger(voice, null, row);
        } else {
          const freq = this.getFreq(row);
          voiceCfg.trigger(voice, freq, row);
        }
      } catch(e) {}
    },

    startDrone() {
      if (!this.ready) return;
      if (this.drone) return;
      this.droneGain = new Tone.Gain(0).toDestination();
      this.droneGain.gain.rampTo(0.15, 1.2);

      this.drone = new Tone.PolySynth(Tone.FMSynth, {
        harmonicity: 2,
        modulationIndex: 1,
        oscillator: { type: 'sine' },
        envelope: { attack: 1, decay: 0, sustain: 1, release: 2 },
        volume: -18,
      }).connect(this.droneGain);

      this._droneLfo = new Tone.LFO('0.25hz', -20, -14).start();
      this._droneLfo.connect(this.drone.volume);

      this.drone.triggerAttack(['A3', 'E4', 'A4']);
    },

    stopDrone() {
      if (!this.drone) return;
      if (this.droneGain) {
        this.droneGain.gain.rampTo(0, 1.5);
      }
      const d = this.drone;
      const g = this.droneGain;
      const l = this._droneLfo;
      setTimeout(() => {
        try { d.releaseAll(); d.dispose(); } catch(e) {}
        try { g.dispose(); } catch(e) {}
        try { l.dispose(); } catch(e) {}
      }, 1600);
      this.drone = null;
      this.droneGain = null;
      this._droneLfo = null;
    },

    setBreathe(active) {
      if (!this.ready) return;
      // Duck all voice volumes during breathe
      for (let i = 0; i < 5; i++) {
        if (this.voices[i]) {
          try { this.voices[i].volume.rampTo(active ? -40 : -14, 0.8); } catch(e) {}
        }
      }
      if (active) this.startDrone();
      else this.stopDrone();
    },
  };
  </script>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect } = React;

    // Grid dimensions: 5 letter blocks, each 6 rows x 3 cols
    const GRID_ROWS = 5;
    const COLS_PER_LETTER = 3;
    const NUM_LETTERS = 5;
    const TOTAL_COLS = NUM_LETTERS * COLS_PER_LETTER; // 15
    const TOTAL_CELLS = TOTAL_COLS * GRID_ROWS; // 90
    const BLOCK_GAP = 8; // px gap between letter blocks (~0.5rem)
    const MAX_GUESSES = 6;

    // Personality avatar images
    const PERSONALITY_AVATARS = {
      'librarian':   'public/bored-librarian.png',
      'lighthouse':  'public/Grumpy-Lighthouse-Keeper.png',
      'pigeon':      'public/confused-pigeon.png',
      'cactus':      'public/Philosophical-Cactus.png',
    };
    const AVATAR_KEYS = Object.keys(PERSONALITY_AVATARS);

    function getAvatarSrc(personality) {
      if (!personality) return PERSONALITY_AVATARS['pigeon'];
      const lower = personality.toLowerCase();
      for (const key of AVATAR_KEYS) {
        if (lower.includes(key)) return PERSONALITY_AVATARS[key];
      }
      // Consistent random pick based on personality string
      const hash = personality.split('').reduce((a, c) => a + c.charCodeAt(0), 0);
      return Object.values(PERSONALITY_AVATARS)[hash % AVATAR_KEYS.length];
    }

    // Helpers
    function colToBlock(col) { return Math.floor(col / COLS_PER_LETTER); }
    function colToSubCol(col) { return col % COLS_PER_LETTER; }
    function isLetterPixel(col, row, input) {
      const block = colToBlock(col);
      const letter = input && input[block];
      if (!letter || !PIXEL_FONT[letter]) return false;
      return PIXEL_FONT[letter][row][colToSubCol(col)] === 1;
    }

    // Pixel font: A-Z as 5 rows x 3 cols (1 = filled, 0 = empty)
    const PIXEL_FONT = {
      'A': [[0,1,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
      'B': [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
      'C': [[0,1,1],[1,0,0],[1,0,0],[1,0,0],[0,1,1]],
      'D': [[1,1,0],[1,0,1],[1,0,1],[1,0,1],[1,1,0]],
      'E': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,1,1]],
      'F': [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
      'G': [[0,1,1],[1,0,0],[1,0,1],[1,0,1],[0,1,1]],
      'H': [[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
      'I': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],
      'J': [[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,0]],
      'K': [[1,0,1],[1,1,0],[1,0,0],[1,1,0],[1,0,1]],
      'L': [[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
      'M': [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
      'N': [[1,0,1],[1,1,1],[1,1,1],[1,0,1],[1,0,1]],
      'O': [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
      'P': [[1,1,0],[1,0,1],[1,1,0],[1,0,0],[1,0,0]],
      'Q': [[0,1,0],[1,0,1],[1,0,1],[1,1,0],[0,1,1]],
      'R': [[1,1,0],[1,0,1],[1,1,0],[1,1,0],[1,0,1]],
      'S': [[0,1,1],[1,0,0],[0,1,0],[0,0,1],[1,1,0]],
      'T': [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],
      'U': [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
      'V': [[1,0,1],[1,0,1],[1,0,1],[0,1,0],[0,1,0]],
      'W': [[1,0,1],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
      'X': [[1,0,1],[1,0,1],[0,1,0],[1,0,1],[1,0,1]],
      'Y': [[1,0,1],[1,0,1],[0,1,0],[0,1,0],[0,1,0]],
      'Z': [[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
    };

    const KB_ROWS = [
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L'],
      ['Z','X','C','V','B','N','M'],
      ['BACK','BREATHE','ENTER'],
    ];

    const FALLBACK_WORDS = [
      'CRANE', 'STARE', 'BLEND', 'FROST', 'PLUMB',
      'GHOST', 'FLAME', 'DRIFT', 'CLOUD', 'PLANT',
      'BRAVE', 'CHARM', 'FLINT', 'GRAPE', 'HOUSE',
      'LIGHT', 'MANGO', 'OCEAN', 'PRIDE', 'QUICK',
      'RAVEN', 'SPINE', 'TORCH', 'VAULT',
    ];

    const GLYPHS = '\u2702\u2706\u2709\u270E\u270F\u2712\u2714\u2716\u271D\u2721\u2726\u2727\u2729\u272A\u272B\u272C\u272D\u272E\u272F\u2730\u2731\u2732\u2733\u2734\u2735\u2736\u2737\u2738\u2739\u273A\u273B\u273C\u273D\u273E\u273F\u2740\u2741\u2742\u2743\u2744\u2745\u2746\u2747\u2748\u2749\u274A\u274B\u274D\u274F\u2750\u2751\u2752\u2756\u2758\u2759\u275A\u275B\u275C\u275D\u275E\u2761\u2762\u2763\u2764\u2765\u2766\u2767';

    const WORD_GEN_PROMPT = `You are the host of Chaos Typewriter, a word-guessing survival game. You have extreme multiple personality disorder. For each word, adopt a COMPLETELY DIFFERENT personality (be creative and unpredictable — surrealist poet, paranoid pigeon theorist, Victorian ghost, condescending alien, dramatic soap opera narrator, medieval knight speaking corporate jargon, etc).

Your job: pick a common 5-letter English word and introduce it with a HELPFUL hint in character.

Format your response EXACTLY as:
[Personality Name]
WORD: XXXXX
HINT1: a vague, cryptic clue (category or mood)
HINT2: a clearer clue (strong association or defining trait)
HINT3: a very direct clue (nearly gives it away — rhyme, first letter, or obvious description)

Rules:
- The word must be a common English word, all letters A-Z, exactly 5 letters
- HINT1 should be vague but in the right direction (e.g. "Something elemental, something warm")
- HINT2 should be clearly helpful (e.g. "You'd find this dancing in a fireplace")
- HINT3 should nearly give it away (e.g. "Rhymes with BLAME, starts with F")
- Deliver ALL hints through your personality's warped lens — be funny AND useful
- Stay fully in character
- NEVER repeat a personality`;

    const REACT_PROMPT = `You are the host of Chaos Typewriter. You are currently playing a character. React to the player's guess in 1 short sentence (max 15 words), staying fully in character. Be funny and weird.`;

    function useScrambleText(finalText, { duration = 2000, interval = 50 } = {}) {
      const [display, setDisplay] = useState('');
      const [done, setDone] = useState(false);

      useEffect(() => {
        const len = finalText.length;
        const totalFrames = Math.floor(duration / interval);
        let frame = 0;

        const timer = setInterval(() => {
          frame++;
          const progress = frame / totalFrames;
          const revealedCount = Math.floor(progress * len);

          let result = '';
          for (let i = 0; i < len; i++) {
            if (finalText[i] === ' ') {
              result += ' ';
            } else if (i < revealedCount) {
              result += finalText[i];
            } else {
              result += GLYPHS[Math.floor(Math.random() * GLYPHS.length)];
            }
          }
          setDisplay(result);

          if (frame >= totalFrames) {
            clearInterval(timer);
            setDisplay(finalText);
            setDone(true);
          }
        }, interval);

        return () => clearInterval(timer);
      }, []);

      return { display, done };
    }

    function evaluateGuess(guess, answer) {
      const result = Array(5).fill('absent');
      const answerChars = answer.split('');
      const guessChars = guess.split('');

      for (let i = 0; i < 5; i++) {
        if (guessChars[i] === answerChars[i]) {
          result[i] = 'correct';
          answerChars[i] = null;
          guessChars[i] = null;
        }
      }

      for (let i = 0; i < 5; i++) {
        if (guessChars[i] === null) continue;
        const idx = answerChars.indexOf(guessChars[i]);
        if (idx !== -1) {
          result[i] = 'present';
          answerChars[idx] = null;
        }
      }

      return result;
    }

    function shuffleArray(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function buildFadeQueue(answer) {
      const answerLetters = new Set(answer.split(''));
      const all = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
      const eliminable = all.filter(l => !answerLetters.has(l));
      return shuffleArray(eliminable);
    }

    function getRandomFallback(exclude) {
      const available = FALLBACK_WORDS.filter(w => !exclude.has(w));
      if (available.length === 0) return null;
      return available[Math.floor(Math.random() * available.length)];
    }

    // ── p5 Sequencer Sketch (instance mode) ──────────────────────

    function createSequencerSketch(containerEl, gameStateRef, callbacksRef) {
      let particles = [];
      let canvasW, canvasH, cellSize, cellGap;
      const MARGIN = 8;

      function computeSize() {
        // Use parent width, falling back to window width minus padding
        canvasW = containerEl.clientWidth || containerEl.parentElement?.clientWidth || Math.min(window.innerWidth - 32, 700);
        cellGap = 2;
        const totalInterCellGaps = (TOTAL_COLS - NUM_LETTERS) * cellGap;
        const totalBlockGaps = (NUM_LETTERS - 1) * BLOCK_GAP;
        const availW = canvasW - 2 * MARGIN - totalInterCellGaps - totalBlockGaps;
        cellSize = Math.floor(availW / TOTAL_COLS);
        canvasH = GRID_ROWS * cellSize + (GRID_ROWS - 1) * cellGap + 2 * MARGIN;
      }

      function getCellPos(col, row) {
        const block = colToBlock(col);
        const subCol = colToSubCol(col);
        // x = margin + (block * 3 cells * size) + (block * 2 intra-gaps) + (block * block-gap) + subCol * (size + gap)
        const x = MARGIN + block * (COLS_PER_LETTER * cellSize + (COLS_PER_LETTER - 1) * cellGap + BLOCK_GAP) + subCol * (cellSize + cellGap);
        const y = MARGIN + row * (cellSize + cellGap);
        return { x, y };
      }

      const sketch = (p) => {
        p.setup = function() {
          computeSize();
          // If container has no width yet, retry after layout
          if (canvasW < 100) {
            setTimeout(() => {
              computeSize();
              p.resizeCanvas(canvasW, canvasH);
            }, 100);
          }
          const canvas = p.createCanvas(canvasW, canvasH);
          canvas.parent(containerEl);
        };

        p.windowResized = function() {
          computeSize();
          p.resizeCanvas(canvasW, canvasH);
        };

        p.draw = function() {
          const state = gameStateRef.current;
          const chaos = state.chaosLevel;
          const now = p.millis();

          // Transparent background
          p.clear();

          // Advance playhead (only when game is running)
          if (state.started) {
            const bpm = 100 + chaos * 40;
            const stepInterval = 60000 / bpm / 4;

            if (now - state.lastStepTime > stepInterval) {
              state.currentStep = (state.currentStep + 1) % TOTAL_COLS;
              state.lastStepTime = now;
              for (let row = 0; row < GRID_ROWS; row++) {
                if (state.nodes[state.currentStep] && state.nodes[state.currentStep][row]) {
                  AudioEngine.playNote(state.currentStep, row, chaos);
                }
              }
            }
          }

          // Playhead column highlight
          if (state.started && state.currentStep >= 0) {
            const { x: phX } = getCellPos(state.currentStep, 0);
            const colH = GRID_ROWS * (cellSize + cellGap) - cellGap;
            // Filled glow behind
            p.noStroke();
            p.fill(160, 120, 200, 50);
            p.rect(phX - 3, MARGIN - 3, cellSize + 6, colH + 6, 5);
            // Border outline
            p.noFill();
            p.stroke(140, 100, 180, 120);
            p.strokeWeight(2);
            p.rect(phX - 3, MARGIN - 3, cellSize + 6, colH + 6, 5);
          }

          // Draw cells
          const guessResult = state.currentGuessResult;
          const input = state.currentInput || '';

          for (let col = 0; col < TOTAL_COLS; col++) {
            const block = colToBlock(col);
            const subCol = colToSubCol(col);
            const isCurrent = col === state.currentStep;

            for (let row = 0; row < GRID_ROWS; row++) {
              const { x, y } = getCellPos(col, row);
              const isActive = state.nodes[col] && state.nodes[col][row];
              const isPixel = isLetterPixel(col, row, input);
              const resultState = guessResult && guessResult[block];

              let r, g, b, a;
              let sr, sg, sb, sa; // stroke color

              if (isPixel && resultState === 'correct') {
                r = 110; g = 195; b = 150; a = 160;
                sr = 80; sg = 170; sb = 120; sa = 120;
              } else if (isPixel && resultState === 'present') {
                r = 210; g = 140; b = 175; a = 160;
                sr = 180; sg = 110; sb = 145; sa = 120;
              } else if (isPixel && resultState === 'absent') {
                r = 160; g = 130; b = 180; a = 110;
                sr = 140; sg = 110; sb = 160; sa = 90;
              } else if (isPixel) {
                // Typed letter — cool gray-purple, subtle
                r = 100; g = 90; b = 120; a = 90;
                sr = 80; sg = 70; sb = 100; sa = 100;
              } else if (isActive) {
                // Chaos node — warm pink-purple, pulsing
                const pulse = Math.sin(now * 0.004 + col * 0.7 + row * 0.3) * 0.15 + 1;
                r = p.lerp(200, 230, chaos);
                g = p.lerp(100, 80, chaos);
                b = p.lerp(160, 140, chaos);
                a = (120 + chaos * 60) * pulse;
                sr = r - 20; sg = g - 10; sb = b - 10; sa = (100 + chaos * 40) * pulse;
              } else {
                // Empty cell — light, minimal
                r = 230; g = 220; b = 235; a = 60;
                sr = 190; sg = 175; sb = 200; sa = 50;
              }

              // Playhead column — draw highlight behind cells
              if (isCurrent && state.started) {
                // Bright cell overlay
                a = Math.min(255, a + 40);
              }

              p.fill(r, g, b, a);
              p.stroke(sr, sg, sb, sa);
              p.strokeWeight(1);
              p.rect(x, y, cellSize, cellSize, cellSize * 0.2);

              // Particles from active cells
              if (isActive && Math.random() < 0.005 + chaos * 0.01) {
                particles.push({
                  x: x + cellSize / 2, y: y + cellSize / 2,
                  vx: p.random(-1, 1), vy: p.random(-1.5, -0.3),
                  life: 1, decay: p.random(0.02, 0.05),
                  r, g, b, size: p.random(2, 4)
                });
              }
            }
          }

          // Breathe overlay
          if (state.breatheActive) {
            p.noStroke();
            p.fill(102, 187, 106, 15 + Math.sin(now * 0.003) * 10);
            p.rect(0, 0, canvasW, canvasH, 8);
          }

          // Particles
          for (let i = particles.length - 1; i >= 0; i--) {
            const pt = particles[i];
            pt.x += pt.vx;
            pt.y += pt.vy;
            pt.life -= pt.decay;
            if (pt.life <= 0) { particles.splice(i, 1); continue; }
            p.noStroke();
            p.fill(pt.r, pt.g, pt.b, pt.life * 180);
            p.ellipse(pt.x, pt.y, pt.size * pt.life);
          }
        };

        p.mousePressed = function() {
          if (!gameStateRef.current.started) return;
          for (let col = 0; col < TOTAL_COLS; col++) {
            for (let row = 0; row < GRID_ROWS; row++) {
              const { x, y } = getCellPos(col, row);
              if (p.mouseX >= x && p.mouseX <= x + cellSize && p.mouseY >= y && p.mouseY <= y + cellSize) {
                if (gameStateRef.current.nodes[col] && gameStateRef.current.nodes[col][row]) {
                  callbacksRef.current.onNodeClick(col, row);
                  // Burst particles
                  for (let j = 0; j < 6; j++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 2.5 + 0.5;
                    particles.push({
                      x: x + cellSize / 2, y: y + cellSize / 2,
                      vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                      life: 1, decay: 0.025 + Math.random() * 0.03,
                      r: 102, g: 187, b: 106, size: 2 + Math.random() * 3
                    });
                  }
                  return;
                }
              }
            }
          }
        };

        p.touchStarted = function() {
          if (!gameStateRef.current.started) return true;
          if (p.mouseX >= 0 && p.mouseX <= canvasW && p.mouseY >= 0 && p.mouseY <= canvasH) {
            p.mousePressed();
            return false;
          }
          return true;
        };
      };

      return new p5(sketch, containerEl);
    }

    // ── Main App ─────────────────────────────────────────────────

    const DIFFICULTY = {
      chill: {
        label: 'Chill', desc: 'No time pressure',
        fadeMin: 8000, fadeMax: 12000, fadeChaosScale: 0.2,
        activateMin: 4000, activateBase: 10000, activateScale: 100,
        creepDelay: 10000, creepRand: 10000, creepProb: 0.008,
        graceDelay: 12000,
      },
      normal: {
        label: 'Normal', desc: 'Balanced challenge',
        fadeMin: 4000, fadeMax: 7000, fadeChaosScale: 0.4,
        activateMin: 2000, activateBase: 6000, activateScale: 150,
        creepDelay: 6000, creepRand: 8000, creepProb: 0.015,
        graceDelay: 8000,
      },
      chaos: {
        label: 'Chaos', desc: 'Good luck',
        fadeMin: 1500, fadeMax: 4000, fadeChaosScale: 0.6,
        activateMin: 600, activateBase: 3000, activateScale: 200,
        creepDelay: 2000, creepRand: 4000, creepProb: 0.04,
        graceDelay: 4000,
      },
    };

    function App() {
      const [setupOpen, setSetupOpen] = useState(false);
      const [apiKey, setApiKey] = useState('');
      const [difficulty, setDifficulty] = useState('normal');
      const [musicVibe, setMusicVibe] = useState('glitchy');
      const [started, setStarted] = useState(false);
      const [showGuide, setShowGuide] = useState(false);
      const [showGameOver, setShowGameOver] = useState(false);
      const [showCongrats, setShowCongrats] = useState(false);

      // Word state
      const [answer, setAnswer] = useState('');
      const [currentInput, setCurrentInput] = useState('');
      const [guessCount, setGuessCount] = useState(0);
      const [letterStates, setLetterStates] = useState({});
      const [fadedLetters, setFadedLetters] = useState(new Set());
      const [guessResult, setGuessResult] = useState(null); // array of 5 states or null
      const [wordPhase, setWordPhase] = useState('waiting'); // waiting | loading | playing | solved | failed

      // Sequencer state
      const [nodes, setNodes] = useState(() => Array.from({ length: TOTAL_COLS }, () => new Array(GRID_ROWS).fill(false)));
      const [chaosLevel, setChaosLevel] = useState(0);
      const [breatheActive, setBreatheActive] = useState(false);
      const [breatheCooldown, setBreatheOnCooldown] = useState(false);
      const [fadePaused, setFadePaused] = useState(false);

      // Hint state — 3 hints per word, revealed at chaos thresholds
      const [hints, setHints] = useState([]); // [{personality, text}, ...] up to 3
      const [hintLevel, setHintLevel] = useState(0); // 0, 1, or 2
      const [currentPersonality, setCurrentPersonality] = useState('');

      // Scoring
      const [wordsCompleted, setWordsCompleted] = useState(0);
      const [totalScore, setTotalScore] = useState(0);
      const [wordStartTime, setWordStartTime] = useState(0);
      const [wordHistory, setWordHistory] = useState([]); // [{word, solved, score, guesses}]

      // Refs
      const sequencerRef = useRef(null);
      const p5Ref = useRef(null);
      const usedWordsRef = useRef(new Set());
      const fadeQueueRef = useRef([]);
      const fadeIndexRef = useRef(0);
      const fadeTimerRef = useRef(null);
      const autoActivateTimerRef = useRef(null);
      const creepBackTimerRef = useRef(null);
      const silencedAtRef = useRef({});
      const abortRef = useRef(null);

      const title = { display: 'Chaos Typewriter', done: true };

      // Shared state ref for p5
      const gameStateRef = useRef({
        started: false,
        nodes: Array.from({ length: TOTAL_COLS }, () => new Array(GRID_ROWS).fill(false)),
        chaosLevel: 0,
        currentStep: -1,
        lastStepTime: 0,
        breatheActive: false,
        currentInput: '',
        currentGuessResult: null,
      });

      const callbacksRef = useRef({
        onNodeClick: () => {},
      });

      // Sync state to ref for p5
      useEffect(() => {
        gameStateRef.current.started = started;
        gameStateRef.current.nodes = nodes;
        gameStateRef.current.chaosLevel = chaosLevel;
        gameStateRef.current.breatheActive = breatheActive;
        gameStateRef.current.currentInput = currentInput;
        gameStateRef.current.currentGuessResult = guessResult;
      }, [started, nodes, chaosLevel, breatheActive, currentInput, guessResult]);

      // Sync music vibe
      useEffect(() => {
        if (started) AudioEngine.setVibe(musicVibe);
      }, [musicVibe, started]);

      // Initialize p5
      useEffect(() => {
        if (sequencerRef.current && !p5Ref.current) {
          p5Ref.current = createSequencerSketch(sequencerRef.current, gameStateRef, callbacksRef);
        }
        return () => {
          if (p5Ref.current) {
            p5Ref.current.remove();
            p5Ref.current = null;
          }
        };
      }, []);

      // Node click callback
      useEffect(() => {
        callbacksRef.current.onNodeClick = (col, row) => {
          setNodes(prev => {
            const next = prev.map(c => [...c]);
            next[col][row] = false;
            return next;
          });
          silencedAtRef.current[`${col},${row}`] = Date.now();
        };
      }, []);


      // Calculate chaos
      useEffect(() => {
        const activeCount = nodes.flat().filter(Boolean).length;
        const target = activeCount / TOTAL_CELLS;
        const interval = setInterval(() => {
          setChaosLevel(prev => prev + (target - prev) * 0.05);
        }, 50);
        return () => clearInterval(interval);
      }, [nodes]);

      // Advance hint level at chaos thresholds (50% → hint 2, 75% → hint 3)
      useEffect(() => {
        if (wordPhase !== 'playing' || hints.length === 0) return;
        const activeCount = nodes.flat().filter(Boolean).length;
        const chaosPercent = activeCount / TOTAL_CELLS * 100;
        if (chaosPercent >= 75 && hints.length >= 3) {
          setHintLevel(2);
        } else if (chaosPercent >= 50 && hints.length >= 2) {
          setHintLevel(1);
        }
      }, [nodes, wordPhase, hints]);

      // Auto-activate nodes — only when actively playing a word
      useEffect(() => {
        if (!started || showGameOver || wordPhase !== 'playing') return;
        const diff = DIFFICULTY[difficulty];
        const initialDelay = guessCount === 0 ? diff.graceDelay : 0;
        const startTimer = setTimeout(() => {
          const tick = () => {
            const delay = Math.max(diff.activateMin, diff.activateBase - wordsCompleted * diff.activateScale);
            autoActivateTimerRef.current = setTimeout(() => {
              setNodes(prev => {
                const inactive = [];
                for (let c = 0; c < TOTAL_COLS; c++) {
                  for (let r = 0; r < GRID_ROWS; r++) {
                    if (!prev[c][r]) inactive.push([c, r]);
                  }
                }
                if (inactive.length === 0) return prev;
                const [tc, tr] = inactive[Math.floor(Math.random() * inactive.length)];
                const next = prev.map(c => [...c]);
                next[tc][tr] = true;
                return next;
              });
              tick();
            }, delay);
          };
          tick();
        }, initialDelay);
        return () => {
          clearTimeout(startTimer);
          clearTimeout(autoActivateTimerRef.current);
        };
      }, [started, wordsCompleted, showGameOver, wordPhase, guessCount, difficulty]);

      // Creep-back for silenced nodes — only during active play
      useEffect(() => {
        if (!started || showGameOver || wordPhase !== 'playing') return;
        creepBackTimerRef.current = setInterval(() => {
          const now = Date.now();
          setNodes(prev => {
            const next = prev.map(c => [...c]);
            let changed = false;
            for (let col = 0; col < TOTAL_COLS; col++) {
              for (let row = 0; row < GRID_ROWS; row++) {
                const key = `${col},${row}`;
                if (!next[col][row] && silencedAtRef.current[key]) {
                  const elapsed = now - silencedAtRef.current[key];
                  const cDiff = DIFFICULTY[difficulty];
                  const delay = cDiff.creepDelay + Math.random() * cDiff.creepRand;
                  if (elapsed > delay && Math.random() < cDiff.creepProb) {
                    next[col][row] = true;
                    delete silencedAtRef.current[key];
                    changed = true;
                  }
                }
              }
            }
            return changed ? next : prev;
          });
        }, 500);
        return () => clearInterval(creepBackTimerRef.current);
      }, [started, showGameOver, wordPhase, difficulty]);

      // Keyboard fading — use setTimeout chain so chaos changes don't reset the timer
      const chaosRef = useRef(0);
      useEffect(() => { chaosRef.current = chaosLevel; }, [chaosLevel]);

      useEffect(() => {
        if (wordPhase !== 'playing' || fadePaused || !answer) return;
        let cancelled = false;
        const tick = () => {
          const fDiff = DIFFICULTY[difficulty];
          const delay = Math.max(fDiff.fadeMin, fDiff.fadeMax * (1 - chaosRef.current * fDiff.fadeChaosScale));
          fadeTimerRef.current = setTimeout(() => {
            if (cancelled) return;
            setFadedLetters(prev => {
              const queue = fadeQueueRef.current;
              const idx = fadeIndexRef.current;
              if (idx >= queue.length) return prev;
              const next = new Set(prev);
              next.add(queue[idx]);
              fadeIndexRef.current = idx + 1;
              return next;
            });
            tick();
          }, delay);
        };
        tick();
        return () => {
          cancelled = true;
          clearTimeout(fadeTimerRef.current);
        };
      }, [wordPhase, fadePaused, answer, difficulty]);

      // Game over check: ~85% of cells active
      useEffect(() => {
        if (!started || showGameOver) return;
        const activeCount = nodes.flat().filter(Boolean).length;
        if (activeCount >= Math.floor(TOTAL_CELLS * 0.85)) {
          const timer = setTimeout(() => {
            const currentActive = nodes.flat().filter(Boolean).length;
            if (currentActive >= Math.floor(TOTAL_CELLS * 0.85)) {
              setShowGameOver(true);
            }
          }, 3000);
          return () => clearTimeout(timer);
        }
      }, [nodes, started, showGameOver]);

      // Breathe mechanic
      const triggerBreathe = useCallback(() => {
        if (breatheCooldown || breatheActive) return;
        setBreatheActive(true);
        setFadePaused(true);
        AudioEngine.setBreathe(true);

        // Silence half the active cells
        setNodes(prev => {
          const next = prev.map(c => [...c]);
          const activeCells = [];
          for (let c = 0; c < TOTAL_COLS; c++) {
            for (let r = 0; r < GRID_ROWS; r++) {
              if (next[c][r]) activeCells.push([c, r]);
            }
          }
          const toCalm = Math.ceil(activeCells.length / 2);
          const shuffled = shuffleArray(activeCells);
          for (let i = 0; i < toCalm; i++) {
            const [c, r] = shuffled[i];
            next[c][r] = false;
            silencedAtRef.current[`${c},${r}`] = Date.now();
          }
          return next;
        });

        setTimeout(() => {
          setBreatheActive(false);
          setFadePaused(false);
          AudioEngine.setBreathe(false);
        }, 4000);

        setBreatheOnCooldown(true);
        setTimeout(() => setBreatheOnCooldown(false), 30000);
      }, [breatheCooldown, breatheActive]);

      // Descriptive fallback hints for each word
      const FALLBACK_HINTS = {
        'CRANE': [
          'Something tall. Could be alive, could be made of steel.',
          'A bird with long legs — or a machine on a construction site.',
          'Rhymes with PLANE, starts with C.',
        ],
        'STARE': [
          'It involves your eyes. Intensity is key.',
          'What you do when you can\'t look away. Unblinking.',
          'Rhymes with CARE, starts with ST.',
        ],
        'BLEND': [
          'About combining things. Think kitchen.',
          'Mix things together until they become one. Smoothies need this.',
          'Starts with BL, ends with END.',
        ],
        'FROST': [
          'Something cold. You see it in winter.',
          'The icy coating on windows on a cold morning.',
          'Rhymes with LOST, starts with FR.',
        ],
        'PLUMB': [
          'Related to straightness, or pipes.',
          'Perfectly vertical — or the person who fixes your sink.',
          'Starts with PL, has a silent B at the end.',
        ],
        'GHOST': [
          'Something spooky. Not quite alive.',
          'A spirit that haunts old houses. Says "boo!"',
          'Rhymes with MOST, starts with GH.',
        ],
        'FLAME': [
          'Something warm and bright. Elemental.',
          'The dancing orange light at the tip of a candle.',
          'Rhymes with BLAME, starts with FL.',
        ],
        'DRIFT': [
          'About movement without control.',
          'To float slowly without direction, like snow piling up.',
          'Starts with DR, ends with IFT.',
        ],
        'CLOUD': [
          'Look up. Way up.',
          'Fluffy white shapes in the sky. Sometimes brings rain.',
          'Rhymes with LOUD, starts with CL.',
        ],
        'PLANT': [
          'Something alive but rooted in place.',
          'A green living thing in soil. Needs water and sunlight.',
          'Rhymes with CANT, starts with PL.',
        ],
        'BRAVE': [
          'A quality of heroes.',
          'Courageous and fearless. The opposite of cowardly.',
          'Rhymes with CAVE, starts with BR.',
        ],
        'CHARM': [
          'Something magnetic about a person.',
          'An irresistible appeal, or a trinket on a bracelet.',
          'Rhymes with FARM, starts with CH.',
        ],
        'FLINT': [
          'Hard and ancient. Makes something useful.',
          'A stone that creates sparks when struck.',
          'Starts with FL, rhymes with MINT.',
        ],
        'GRAPE': [
          'Something you eat. Grows in clusters.',
          'A small round fruit on a vine. Makes wine.',
          'Rhymes with TAPE, starts with GR.',
        ],
        'HOUSE': [
          'Where life happens. Everyone needs one.',
          'Where you live. Rooms, a roof, a door.',
          'Rhymes with MOUSE, starts with H.',
        ],
        'LIGHT': [
          'Without it, you see nothing.',
          'What lets you see in the dark. The sun gives plenty.',
          'Rhymes with NIGHT, starts with L.',
        ],
        'MANGO': [
          'Tropical and sweet.',
          'An orange fruit, popular in smoothies and lassi.',
          'Starts with MAN, ends with GO.',
        ],
        'OCEAN': [
          'Vast and blue. Covers most of Earth.',
          'The enormous body of salt water between continents.',
          'Starts with O, ends with AN. 5 letters.',
        ],
        'PRIDE': [
          'A feeling, or a group of animals.',
          'Deep satisfaction — or what you call a group of lions.',
          'Rhymes with RIDE, starts with PR.',
        ],
        'QUICK': [
          'The opposite of slow.',
          'Fast, speedy, without delay.',
          'Starts with QU, rhymes with STICK.',
        ],
        'RAVEN': [
          'A dark bird. Literary fame.',
          'A large intelligent black bird. Poe wrote about one.',
          'Starts with R, rhymes with HAVEN.',
        ],
        'SPINE': [
          'Something structural. In your body and in books.',
          'The column of bones down your back. Also the edge of a book.',
          'Rhymes with MINE, starts with SP.',
        ],
        'TORCH': [
          'Portable brightness.',
          'A light you carry in the dark. Flashlight in the US.',
          'Rhymes with PORCH, starts with T.',
        ],
        'VAULT': [
          'Security or athletics.',
          'A secure room for valuables — or a gymnastic jump.',
          'Rhymes with SALT, starts with V.',
        ],
      };

      function generateFallbackHints(word) {
        const fb = FALLBACK_HINTS[word];
        if (fb) return fb;
        // Generic 3-level hints
        const vowels = word.split('').filter(l => 'AEIOU'.includes(l)).length;
        return [
          `${vowels} vowel${vowels !== 1 ? 's' : ''}. Think carefully.`,
          `It starts with a letter from the ${word[0] <= 'M' ? 'first' : 'second'} half of the alphabet.`,
          `Starts with "${word[0]}", ends with "${word[4]}".`,
        ];
      }

      const FALLBACK_PERSONALITIES = [
        'Mysterious Oracle', 'Bored Librarian', 'Excitable Squirrel',
        'Grumpy Lighthouse Keeper', 'Time-Traveling Barista', 'Philosophical Cactus',
        'Overly Dramatic Narrator', 'Confused Pigeon', 'Sarcastic Fortune Cookie',
      ];

      // Fetch word from AI
      const fetchNextWord = useCallback(async () => {
        setWordPhase('loading');
        setCurrentInput('');
        setGuessCount(0);
        setLetterStates({});
        setFadedLetters(new Set());
        setGuessResult(null);
        fadeIndexRef.current = 0;

        let word, personality, hint1, hint2, hint3;

        if (apiKey) {
          try {
            if (abortRef.current) abortRef.current.abort();
            const controller = new AbortController();
            abortRef.current = controller;

            const res = await fetch('https://api.anthropic.com/v1/messages', {
              method: 'POST',
              signal: controller.signal,
              headers: {
                'content-type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true',
              },
              body: JSON.stringify({
                model: 'claude-haiku-4-5-20251001',
                max_tokens: 250,
                system: WORD_GEN_PROMPT,
                messages: [{ role: 'user', content: `Give me word #${wordsCompleted + 1}. Previous words used: ${[...usedWordsRef.current].join(', ') || 'none'}` }],
              }),
            });

            if (!res.ok) throw new Error(`API ${res.status}`);
            const data = await res.json();
            const reply = data.content?.[0]?.text || '';

            // Parse response
            const persMatch = reply.match(/^\[([^\]]+)\]/);
            personality = persMatch ? persMatch[1] : 'Mystery Host';

            const wordMatch = reply.match(/WORD:\s*([A-Z]{5})/i);
            word = wordMatch ? wordMatch[1].toUpperCase() : null;

            const h1 = reply.match(/HINT1:\s*(.+)/i);
            const h2 = reply.match(/HINT2:\s*(.+)/i);
            const h3 = reply.match(/HINT3:\s*(.+)/i);
            hint1 = h1 ? h1[1].trim() : null;
            hint2 = h2 ? h2[1].trim() : null;
            hint3 = h3 ? h3[1].trim() : null;

            if (!word || word.length !== 5 || !/^[A-Z]+$/.test(word)) {
              throw new Error('Bad word from AI');
            }
          } catch (e) {
            if (e.name === 'AbortError') return;
            word = null;
          }
        }

        // Fallback: pick a word and generate hints + random personality
        if (!word) {
          word = getRandomFallback(usedWordsRef.current);
          if (!word) {
            // All fallback words exhausted — you win!
            setWordPhase('idle');
            setShowCongrats(true);
            if (audioRef.current) audioRef.current.stopAll();
            return;
          }
          if (!personality) {
            personality = FALLBACK_PERSONALITIES[Math.floor(Math.random() * FALLBACK_PERSONALITIES.length)];
          }
          const fb = generateFallbackHints(word);
          hint1 = hint1 || fb[0];
          hint2 = hint2 || fb[1];
          hint3 = hint3 || fb[2];
        }

        usedWordsRef.current.add(word);
        setAnswer(word);
        fadeQueueRef.current = buildFadeQueue(word);
        fadeIndexRef.current = 0;
        setCurrentPersonality(personality);
        setHintLevel(0);

        // Set all 3 hints
        const wordHints = [
          { personality, text: hint1 || 'Good luck...' },
          { personality, text: hint2 || 'Getting warmer...' },
          { personality, text: hint3 || `It starts with ${word[0]}...` },
        ];
        setHints(wordHints);

        // Brief pause so player can read the hint before play begins
        await new Promise(resolve => setTimeout(resolve, 1500));

        setWordStartTime(Date.now());
        setWordPhase('playing');
      }, [apiKey, wordsCompleted]);

      // React to guess via AI
      const aiReactToGuess = useCallback(async (guess, wasCorrect) => {
        if (!apiKey || !currentPersonality) return;
        try {
          const res = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'content-type': 'application/json',
              'x-api-key': apiKey,
              'anthropic-version': '2023-06-01',
              'anthropic-dangerous-direct-browser-access': 'true',
            },
            body: JSON.stringify({
              model: 'claude-haiku-4-5-20251001',
              max_tokens: 60,
              system: REACT_PROMPT + ` You are [${currentPersonality}]. The answer is "${answer}". The player guessed "${guess}". ${wasCorrect ? 'They got it right!' : 'They got it wrong.'}`,
              messages: [{ role: 'user', content: 'React.' }],
            }),
          });
          if (!res.ok) return;
          const data = await res.json();
          const reply = (data.content?.[0]?.text || '').replace(/^\[.*?\]\s*/, '').trim();
          if (reply) {
            setHints(prev => {
              const next = [...prev];
              if (next[hintLevel]) next[hintLevel] = { ...next[hintLevel], text: reply };
              return next;
            });
          }
        } catch {}
      }, [apiKey, currentPersonality, answer, hintLevel]);

      // Submit guess
      const submitGuess = useCallback(() => {
        if (currentInput.length !== 5 || wordPhase !== 'playing') return;

        const guess = currentInput.toUpperCase();
        const result = evaluateGuess(guess, answer);
        setGuessResult(result);
        const newGuessCount = guessCount + 1;
        setGuessCount(newGuessCount);

        // Update letter states
        const priority = { correct: 3, present: 2, absent: 1 };
        setLetterStates(prev => {
          const next = { ...prev };
          for (let i = 0; i < 5; i++) {
            const letter = guess[i];
            const state = result[i];
            if (!next[letter] || priority[state] > priority[next[letter]]) {
              next[letter] = state;
            }
          }
          return next;
        });

        const isCorrect = guess === answer;

        // AI reaction (fire and forget)
        aiReactToGuess(guess, isCorrect);

        // Delay to show result, then proceed
        setTimeout(() => {
          if (isCorrect) {
            // Solved!
            const elapsed = (Date.now() - wordStartTime) / 1000;
            const score = Math.max(0, 1000 - Math.floor(elapsed * 10) - (newGuessCount * 50));
            setTotalScore(prev => prev + score);
            setWordsCompleted(prev => prev + 1);
            setWordPhase('solved');

            // Silence 5-8 cells based on speed
            const speedBonus = newGuessCount <= 2 ? 3 : newGuessCount <= 4 ? 1 : 0;
            const toSilence = 5 + speedBonus;
            setNodes(prev => {
              const next = prev.map(c => [...c]);
              const activeCells = [];
              for (let c = 0; c < TOTAL_COLS; c++) {
                for (let r = 0; r < GRID_ROWS; r++) {
                  if (next[c][r]) activeCells.push([c, r]);
                }
              }
              const shuffled = shuffleArray(activeCells);
              for (let i = 0; i < Math.min(toSilence, shuffled.length); i++) {
                const [c, r] = shuffled[i];
                next[c][r] = false;
                silencedAtRef.current[`${c},${r}`] = Date.now();
              }
              return next;
            });

            setWordHistory(prev => [...prev, { word: answer, solved: true, score, guesses: newGuessCount }]);
            setHints([]);
            setHintLevel(0);

            // Next word after a pause
            setTimeout(() => {
              setGuessResult(null);
              setCurrentInput('');
              fetchNextWord();
            }, 1500);

          } else if (newGuessCount >= MAX_GUESSES) {
            // Failed
            setWordPhase('failed');

            // Activate 4-6 more cells
            setNodes(prev => {
              const next = prev.map(c => [...c]);
              const inactiveCells = [];
              for (let c = 0; c < TOTAL_COLS; c++) {
                for (let r = 0; r < GRID_ROWS; r++) {
                  if (!next[c][r]) inactiveCells.push([c, r]);
                }
              }
              const shuffled = shuffleArray(inactiveCells);
              for (let i = 0; i < Math.min(5, shuffled.length); i++) {
                const [c, r] = shuffled[i];
                next[c][r] = true;
              }
              return next;
            });

            setWordHistory(prev => [...prev, { word: answer, solved: false, score: 0, guesses: newGuessCount }]);
            setHints([]);
            setHintLevel(0);

            // Next word after a pause
            setTimeout(() => {
              setGuessResult(null);
              setCurrentInput('');
              fetchNextWord();
            }, 2000);

          } else {
            // Clear input for next guess, keep result briefly
            setTimeout(() => {
              setGuessResult(null);
              setCurrentInput('');
            }, 800);
          }
        }, 600);
      }, [currentInput, wordPhase, answer, guessCount, aiReactToGuess, fetchNextWord, wordStartTime]);

      // Handle key
      const handleKey = useCallback((key) => {
        if (wordPhase !== 'playing' || guessResult) return;

        if (key === 'ENTER') {
          if (currentInput.length === 5) submitGuess();
        } else if (key === 'BACK' || key === 'BACKSPACE') {
          setCurrentInput(prev => prev.slice(0, -1));
        } else if (/^[A-Z]$/.test(key) && currentInput.length < 5) {
          if (fadedLetters.has(key) && !letterStates[key]) return;
          setCurrentInput(prev => prev + key);
        }
      }, [wordPhase, guessResult, currentInput, submitGuess, fadedLetters, letterStates]);

      // Physical keyboard
      useEffect(() => {
        const handler = (e) => {
          if (e.ctrlKey || e.metaKey || e.altKey) return;
          const key = e.key.toUpperCase();
          if (key === 'ENTER' || key === 'BACKSPACE' || (/^[A-Z]$/.test(key) && key.length === 1)) {
            e.preventDefault();
            handleKey(key);
          }
          if (e.key === ' ') {
            e.preventDefault();
          }
        };
        window.addEventListener('keydown', handler);
        return () => window.removeEventListener('keydown', handler);
      }, [handleKey, triggerBreathe]);

      // Start game
      const handleStart = useCallback(async () => {
        await AudioEngine.init();
        AudioEngine.setVibe(musicVibe);
        setStarted(true);
        gameStateRef.current.lastStepTime = performance.now();

        // Seed 6 random active cells
        setNodes(() => {
          const next = Array.from({ length: TOTAL_COLS }, () => new Array(GRID_ROWS).fill(false));
          const allCells = [];
          for (let c = 0; c < TOTAL_COLS; c++) {
            for (let r = 0; r < GRID_ROWS; r++) allCells.push([c, r]);
          }
          const shuffled = shuffleArray(allCells);
          for (let i = 0; i < 6; i++) {
            const [c, r] = shuffled[i];
            next[c][r] = true;
          }
          return next;
        });

        // Show guide on first visit
        if (!localStorage.getItem('chaos-typewriter-guide-seen')) {
          setShowGuide(true);
          localStorage.setItem('chaos-typewriter-guide-seen', '1');
        }

        fetchNextWord();
      }, [fetchNextWord, musicVibe]);

      // Restart
      const handleRestart = useCallback(() => {
        setShowGameOver(false);
        setShowCongrats(false);
        setChaosLevel(0);
        setWordsCompleted(0);
        setTotalScore(0);
        setWordHistory([]);
        setHints([]);
        setHintLevel(0);
        usedWordsRef.current = new Set();
        silencedAtRef.current = {};

        // Seed 6 random active cells
        setNodes(() => {
          const next = Array.from({ length: TOTAL_COLS }, () => new Array(GRID_ROWS).fill(false));
          const allCells = [];
          for (let c = 0; c < TOTAL_COLS; c++) {
            for (let r = 0; r < GRID_ROWS; r++) allCells.push([c, r]);
          }
          const shuffled = shuffleArray(allCells);
          for (let i = 0; i < 6; i++) {
            const [c, r] = shuffled[i];
            next[c][r] = true;
          }
          return next;
        });

        fetchNextWord();
      }, [fetchNextWord]);

      const activeCount = nodes.flat().filter(Boolean).length;
      const maxNonWord = TOTAL_CELLS;

      return (
        <>
          <nav>
            <a href="index.html">&larr; Back to all projects</a>
            <div className="nav-controls">
              <button className="help-btn" onClick={() => setShowGuide(true)} title="How to Play">?</button>
              <button className="setup-toggle" onClick={() => setSetupOpen(!setupOpen)}>Setup <span className={`arrow${setupOpen ? ' open' : ''}`}>▶</span></button>
            </div>
          </nav>
          <div className={`setup-panel ${setupOpen ? 'open' : ''}`}>
            <div className="setup-row">
              <label>Difficulty</label>
              <div className="difficulty-options">
                {Object.entries(DIFFICULTY).map(([key, val]) => (
                  <button
                    key={key}
                    className={`diff-btn ${difficulty === key ? 'active' : ''}`}
                    onClick={() => setDifficulty(key)}
                  >
                    <span className="diff-label">{val.label}</span>
                    <span className="diff-desc">{val.desc}</span>
                  </button>
                ))}
              </div>
            </div>
            <div className="setup-row">
              <label>Music</label>
              <div className="difficulty-options">
                {Object.entries(VIBES).map(([key, val]) => (
                  <button
                    key={key}
                    className={`diff-btn ${musicVibe === key ? 'active' : ''}`}
                    onClick={() => setMusicVibe(key)}
                  >
                    <span className="diff-label">{val.label}</span>
                    <span className="diff-desc">{val.desc}</span>
                  </button>
                ))}
              </div>
            </div>
            <div className="setup-row">
              <label>API Key <span style={{fontWeight:500, textTransform:'none', letterSpacing:0, color:'#b07cd8'}}>(optional)</span></label>
              <input
                type="password"
                placeholder="sk-ant-... (optional — uses fallback words without it)"
                value={apiKey}
                onChange={e => setApiKey(e.target.value)}
              />
            </div>
          </div>

          <div className="header">
            <h1><span className="title-chaos">Chaos</span> <span className="title-typewriter">Typewriter</span></h1>
            <p className="byline">Vibeshift BLR Combo</p>
          </div>

          <div className="game-area">
            {/* Hint bubble + stats row */}
            <div className="hint-stats-row">
              <div className="hint-bubble-wrap">
                {hints.length > 0 && hints[hintLevel] ? (
                  <div className="hint-bubble">
                    <img className="hint-icon" src={getAvatarSrc(currentPersonality)} alt="" />
                    <div className="hint-content">
                      <span className="hint-personality">{hints[hintLevel].personality}</span>
                      <span className="hint-text">{hints[hintLevel].text}</span>
                    </div>
                  </div>
                ) : wordPhase === 'loading' ? (
                  <div className="hint-bubble waiting">
                    <img className="hint-icon" src={getAvatarSrc(currentPersonality)} alt="" />
                    <span className="hint-waiting">thinking of a word...</span>
                  </div>
                ) : wordPhase === 'solved' ? (
                  <div className="hint-bubble">
                    <img className="hint-icon" src={getAvatarSrc(currentPersonality)} alt="" />
                    <span className="hint-waiting">nice! next word coming...</span>
                  </div>
                ) : wordPhase === 'failed' ? (
                  <div className="hint-bubble">
                    <img className="hint-icon" src={getAvatarSrc(currentPersonality)} alt="" />
                    <span className="hint-waiting">the word was {answer}... next one coming...</span>
                  </div>
                ) : null}
              </div>
              <div className="game-stats">
                <div><span className="stat-number">{guessCount + 1}</span> of <span className="stat-number">{MAX_GUESSES}</span> <span className="stat-label">word</span></div>
                <div><span className="stat-number">{totalScore}</span> <span className="stat-label">points</span></div>
                <div><span className="stat-number">{Math.round(activeCount / maxNonWord * 100)}%</span> <span className="stat-label">chaos</span></div>
              </div>
            </div>

            <div id="sequencer-container" ref={sequencerRef}></div>

            <div className="keyboard">
              {KB_ROWS.map((row, ri) => (
                <div key={ri} className="kb-row">
                  {row.map(key => {
                    if (key === 'BREATHE') {
                      return (
                        <button
                          key={key}
                          className={`key breathe-key${breatheActive ? ' correct' : breatheCooldown ? ' absent' : ''}`}
                          onClick={() => triggerBreathe()}
                        >
                          BREATHE
                        </button>
                      );
                    }
                    let cls = 'key';
                    if (key === 'ENTER' || key === 'BACK') cls += ' wide';
                    if (letterStates[key]) cls += ` ${letterStates[key]}`;
                    else if (fadedLetters.has(key)) cls += ' faded';
                    return (
                      <button
                        key={key}
                        className={cls}
                        onClick={() => handleKey(key)}
                      >
                        {key === 'BACK' ? '\u232B' : key}
                      </button>
                    );
                  })}
                </div>
              ))}
            </div>
          </div>

          {/* Start Overlay */}
          {!started && (
            <div className="modal-overlay" onClick={handleStart}>
              <div className="modal guide" onClick={e => e.stopPropagation()}>
                <h2>How to Play</h2>
                <p>1. Guess <strong>5-letter words</strong> to survive.</p>
                <p>2. <strong>Cryptic hints</strong> will be provided by a different personality each round.</p>
                <p>3. <strong>Game over</strong> when the grid is overwhelmed with chaos.</p>
                <button className="btn" onClick={handleStart}>Click to begin</button>
              </div>
            </div>
          )}

          {/* How to Play */}
          {showGuide && (
            <div className="modal-overlay" onClick={() => setShowGuide(false)}>
              <div className="modal guide" onClick={e => e.stopPropagation()}>
                <h2>How to Play</h2>
                <p>1. Guess <strong>5-letter words</strong> to survive.</p>
                <p>2. <strong>Cryptic hints</strong> will be provided by a different personality each round.</p>
                <p>3. <strong>Game over</strong> when the grid is overwhelmed with chaos.</p>
                <button className="btn" onClick={() => setShowGuide(false)}>Got it</button>
              </div>
            </div>
          )}

          {/* Game Over */}
          {showGameOver && (
            <div className="modal-overlay">
              <div className="modal">
                <div className="modal-icon">{'\uD83C\uDF2A\uFE0F'}</div>
                <h2>Chaos Wins!</h2>
                {answer && wordPhase !== 'solved' && (
                  <div className="current-word-reveal">
                    The word was: {answer}
                  </div>
                )}
                <div className="modal-stats">
                  <div className="modal-stat">
                    <span className="stat-value">{totalScore}</span>
                    <span className="stat-label">Score</span>
                  </div>
                  <div className="modal-stat">
                    <span className="stat-value">{wordsCompleted}</span>
                    <span className="stat-label">Solved</span>
                  </div>
                  <div className="modal-stat">
                    <span className="stat-value">{wordHistory.length + (wordPhase !== 'solved' && answer ? 1 : 0)}</span>
                    <span className="stat-label">Total</span>
                  </div>
                </div>
                {(wordHistory.length > 0 || answer) && (
                  <div className="word-list">
                    {wordHistory.map((w, i) => (
                      <div key={i} className="word-item">
                        <span className="word-text">{w.word}</span>
                        <span className={`word-badge ${w.solved ? 'solved' : 'missed'}`}>
                          {w.solved ? `+${w.score}` : 'missed'}
                        </span>
                      </div>
                    ))}
                    {answer && wordPhase !== 'solved' && (
                      <div className="word-item">
                        <span className="word-text">{answer}</span>
                        <span className="word-badge missed">in progress</span>
                      </div>
                    )}
                  </div>
                )}
                <button className="btn" onClick={handleRestart}>Play Again</button>
              </div>
            </div>
          )}

          {/* Congrats — all words cleared */}
          {showCongrats && (
            <div className="modal-overlay">
              <div className="modal">
                <div className="modal-icon">{'\uD83C\uDF89'}</div>
                <h2>You Beat the Chaos!</h2>
                <p style={{margin: '0.5rem 0 1rem', color: '#b07cd8', fontSize: '1rem'}}>
                  All {FALLBACK_WORDS.length} words conquered
                </p>
                <div className="modal-stats">
                  <div className="modal-stat">
                    <span className="stat-value">{totalScore}</span>
                    <span className="stat-label">Score</span>
                  </div>
                  <div className="modal-stat">
                    <span className="stat-value">{wordsCompleted}</span>
                    <span className="stat-label">Solved</span>
                  </div>
                  <div className="modal-stat">
                    <span className="stat-value">{wordHistory.length}</span>
                    <span className="stat-label">Total</span>
                  </div>
                </div>
                {wordHistory.length > 0 && (
                  <div className="word-list">
                    {wordHistory.map((w, i) => (
                      <div key={i} className="word-item">
                        <span className="word-text">{w.word}</span>
                        <span className={`word-badge ${w.solved ? 'solved' : 'missed'}`}>
                          {w.solved ? `+${w.score}` : 'missed'}
                        </span>
                      </div>
                    ))}
                  </div>
                )}
                <button className="btn" onClick={handleRestart}>Play Again</button>
              </div>
            </div>
          )}
        </>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
